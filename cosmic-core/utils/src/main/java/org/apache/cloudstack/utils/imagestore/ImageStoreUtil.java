package org.apache.cloudstack.utils.imagestore;

import com.cloud.utils.script.Script;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ImageStoreUtil {
    public static final Logger s_logger = LoggerFactory.getLogger(ImageStoreUtil.class.getName());

    public static String generatePostUploadUrl(final String ssvmUrlDomain, final String ipAddress, final String uuid) {
        String hostname = ipAddress;

        //if ssvm url domain is present, use it to construct hostname in the format 1-2-3-4.domain
        // if the domain name is not present, ssl validation fails and has to be ignored
        if (StringUtils.isNotBlank(ssvmUrlDomain)) {
            hostname = ipAddress.replace(".", "-");
            hostname = hostname + ssvmUrlDomain.substring(1);
        }

        //only https works with postupload and url format is fixed
        return "https://" + hostname + "/upload/" + uuid;
    }

    // given a path, returns empty if path is supported image, and the file type if unsupported
    // this is meant to catch things like accidental upload of ASCII text .vmdk descriptor
    public static String checkTemplateFormat(final String path, final String uripath) {
        // note 'path' was generated by us so it should be safe on the cmdline, be wary of 'url'
        String command = "file ";
        if (isCompressedExtension(uripath)) {
            command = "file -z ";
        }
        final String output = Script.runSimpleBashScript(command + path + " | cut -d: -f2", 60000);

        // raw
        if ((output.contains("x86 boot") || output.contains("data")) && (isCorrectExtension(uripath, "raw") || isCorrectExtension(uripath, "img"))) {
            s_logger.debug("File at path " + path + " looks like a raw image :" + output);
            return "";
        }
        // qcow2
        if (output.contains("QEMU QCOW") && isCorrectExtension(uripath, "qcow2")) {
            s_logger.debug("File at path " + path + " looks like QCOW2 : " + output);
            return "";
        }
        // vhd
        if (output.contains("Microsoft Disk Image") && (isCorrectExtension(uripath, "vhd") || isCorrectExtension(uripath, "vhdx"))) {
            s_logger.debug("File at path " + path + " looks like vhd : " + output);
            return "";
        }

        //lxc
        if (output.contains("POSIX tar") && isCorrectExtension(uripath, "tar")) {
            s_logger.debug("File at path " + path + " looks like just tar : " + output);
            return "";
        }

        if (output.contains("ISO 9660") && isCorrectExtension(uripath, "iso")) {
            s_logger.debug("File at path " + path + " looks like an iso : " + output);
            return "";
        }
        return output;
    }

    private static boolean isCompressedExtension(final String path) {
        if (path.toLowerCase().endsWith(".gz")
                || path.toLowerCase().endsWith(".bz2")
                || path.toLowerCase().endsWith(".zip")) {
            return true;
        }
        return false;
    }

    private static boolean isCorrectExtension(final String path, final String ext) {
        if (path.toLowerCase().endsWith(ext)
                || path.toLowerCase().endsWith(ext + ".gz")
                || path.toLowerCase().endsWith(ext + ".bz2")
                || path.toLowerCase().endsWith(ext + ".zip")) {
            return true;
        }
        return false;
    }
}

